// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc6033.RobotCodeJava2018;

import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.DriverStation.Alliance;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc6033.RobotCodeJava2018.util.GameData;
import org.usfirst.frc6033.RobotCodeJava2018.util.VisionData;
import org.usfirst.frc6033.RobotCodeJava2018.commands.*;
import org.usfirst.frc6033.RobotCodeJava2018.subsystems.*;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the TimedRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the build.properties file in the
 * project.
 */
public class Robot extends TimedRobot {

	Command autonomousCommand;
	SendableChooser chooser;

	public static OI oi;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public static Drive drive;
	public static Camera camera;
	public static TopCamera topCamera;
	public static Elevator elevator;
	public static ForkWrist wrist;
	public static ForkClamp clamp;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public static GameData gameData = RobotMap.gameData;

	public static double AutoSpeed = .6;
	public static double AutoTurnSpeed = 0.65;
	public static double AutoApproachSpeed = 0.35;
	public static double AutoDwell = 0.6; // 0.5; //changed to 1.0 to allow a moment for sound to stop
											// and get more accurate sonar distance
	public static double AutoScale = 1.0; // 1.0;

	public static double RobotLengthInches = 37.0;// old robot
	// public static double RobotLengthInches = 32.25;//new robot
	public static double RobotWidthInches = 27.0; // old robot
	// public static double RobotWidthInches = 23.5; //new robot
	public static double SensorOffsetInches = 3.75; // old robot
	// public static double SensorOffsetInches = ?; //new robot

	public DriverStation driveStation;
	public CameraServer cameraServerFront;
	public CameraServer cameraServerBack;
	public Alliance alliance;

	public double gyroAngle;
	public static VisionData visionData;

	private int startLocation;

	private int cycleCounter = 0;
	private int currentLight = 0;
	private int logoCycleCounter = 0;

	/**
	 * This function is run when the robot is first started up and should be used
	 * for any initialization code.
	 */
	@Override
	public void robotInit() {
		RobotMap.init();

		gameData = new GameData();
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		drive = new Drive();
		camera = new Camera();
		topCamera = new TopCamera();
		elevator = new Elevator();
		wrist = new ForkWrist();
		clamp = new ForkClamp();

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		// OI must be constructed after subsystems. If the OI creates Commands
		// (which it very likely will), subsystems are not guaranteed to be
		// constructed yet. Thus, their requires() statements may grab null
		// pointers. Bad news. Don't move it.
		oi = new OI();

		// Add commands to Autonomous Sendable Chooser
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

		chooser = new SendableChooser();
		chooser.addDefault("AutoNothing", "NOTHING");
		chooser.addObject("AutoSideLeft", "LEFT");
		chooser.addObject("AutoSideRight", "RIGHT");
		chooser.addObject("AutoCenter", "CENTER");
		chooser.addObject("AutoTurnLeft", "TURN_LEFT");
		chooser.addObject("AutoTurnRight", "TURN_RIGHT");
		chooser.addObject("AutoCrossLine", "CROSS_LINE");
		SmartDashboard.putData("Automode", chooser);

		visionData = new VisionData();

		driveStation = DriverStation.getInstance();
		// added 1-16-18 Bill S
		alliance = driveStation.getAlliance();
		startLocation = driveStation.getLocation();

		cameraServerFront = CameraServer.getInstance();
		cameraServerFront.startAutomaticCapture();
		cameraServerBack = CameraServer.getInstance();
		cameraServerBack.startAutomaticCapture();

		elevator.resetEncoders();

	}

	/**
	 * This function is called when the disabled button is hit. You can use it to
	 * reset subsystems before shutting down.
	 */
	@Override
	public void disabledInit() {
		camera.allLights(false);
	}

	@Override
	public void disabledPeriodic() {
		gameData.setGameData(driveStation.getGameSpecificMessage());
		SmartDashboard.putString("gameData", gameData.getGameData());
		Scheduler.getInstance().run();
		updateDashboardParameters();
		flashLogo();
	}

	@Override
	public void autonomousInit() {
		clamp.clampClose();
		gameData.setGameData(driveStation.getGameSpecificMessage());
		SmartDashboard.putString("gameData", gameData.getGameData());

		// autonomousCommand = (Command) new AutoCenter();

		switch ((String) chooser.getSelected()) {
		case "LEFT":
			autonomousCommand = (Command) new AutoSideLeft();
			break;
		case "RIGHT":
			autonomousCommand = (Command) new AutoSideRight();
			break;
		case "CENTER":
			autonomousCommand = (Command) new AutoCenter();
			break;
		case "TURN_LEFT":
			autonomousCommand = (Command) new AutoTurnLeft();
			break;
		case "TURN_RIGHT":
			autonomousCommand = (Command) new AutoTurnRight();
			break;
		case "CROSS_LINE":
			autonomousCommand = (Command) new AutoCrossLine();
			break;
		default:
			autonomousCommand = (Command) new AutoNothing();

		}

		// schedule the autonomous command (example)
		if (autonomousCommand != null) {
			autonomousCommand.start();
		}
		camera.allLights(true);
		topCamera.setTiltAngle(90);
		camera.setPanServoAngle(55);
		camera.setAllianceColor(alliance.toString());
	}

	/**
	 * This function is called periodically during autonomous
	 */
	@Override
	public void autonomousPeriodic() {
		gameData.setGameData(driveStation.getGameSpecificMessage());
		SmartDashboard.putString("gameData", gameData.getGameData());
		Scheduler.getInstance().run();
		updateDashboardParameters();
	}

	@Override
	public void teleopInit() {
		// This makes sure that the autonomous stops running when
		// teleop starts running. If you want the autonomous to
		// continue until interrupted by another command, remove
		// this line or comment it out.
		if (autonomousCommand != null)
			autonomousCommand.cancel();
		topCamera.setTiltAngle(90);
		camera.setPanServoAngle(55);
		camera.setAllianceColor(alliance.toString());
	}

	/**
	 * This function is called periodically during operator control
	 */
	@Override
	public void teleopPeriodic() {
		Scheduler.getInstance().run();
		updateDashboardParameters();
		flashLights();
		// flashLogo();

		double innerElevatorControl = oi.getGamepad().getRawAxis(5) * -1;
		double outerElevatorControl = oi.getGamepad().getRawAxis(1) * -1;

		if (Math.abs(innerElevatorControl) < 0.1)
			innerElevatorControl = 0;
		if (Math.abs(outerElevatorControl) < 0.1)
			outerElevatorControl = 0;

		// inner has forks
		// outer does not
		/*
		 * if (innerElevatorControl < 0) { if (elevator.getDistanceInnerSectionEncoder()
		 * > elevator.innerDownLimit || oi.getGamepad().getAButtonPressed())
		 * elevator.setInnerMotor(innerElevatorControl); else elevator.stopInnerMotor();
		 * } else if (innerElevatorControl > 0) { if
		 * (elevator.getDistanceInnerSectionEncoder() < elevator.innerUpLimit ||
		 * oi.getGamepad().getAButtonPressed())
		 * elevator.setInnerMotor(innerElevatorControl); else elevator.stopInnerMotor();
		 * } else elevator.stopInnerMotor();
		 * 
		 * if (outerElevatorControl < 0) { if (elevator.getDistanceOuterSectionEncoder()
		 * > elevator.outerDownLimit || oi.getGamepad().getAButtonPressed())
		 * elevator.setOuterMotor(outerElevatorControl); else elevator.stopOuterMotor();
		 * } else if (outerElevatorControl > 0) { if
		 * (elevator.getDistanceOuterSectionEncoder() < elevator.outerUpLimit ||
		 * oi.getGamepad().getAButtonPressed())
		 * elevator.setOuterMotor(outerElevatorControl); else elevator.stopOuterMotor();
		 * } else elevator.stopOuterMotor();
		 */
		if (innerElevatorControl != 0)
			elevator.setInnerMotor(innerElevatorControl);
		else
			elevator.stopInnerMotor();
		if (outerElevatorControl != 0)
			elevator.setOuterMotor(outerElevatorControl);
		else
			elevator.stopOuterMotor();
		SmartDashboard.putNumber("innerElevatorControl", innerElevatorControl);
		SmartDashboard.putNumber("outerElevatorControl", outerElevatorControl);

		// elevator.setInnerMotor(oi.getGamepad().getRawAxis(1));
		// elevator.setOuterMotor(oi.getGamepad().getRawAxis(5));
		if (oi.getGamepad().getPOV() == 0) {
			wrist.tiltForks(-1);
		} else if (oi.getGamepad().getPOV() == 180) {
			wrist.tiltForks(1);
		} else {
			wrist.stopForks();
		}
	}

	private void updateDashboardParameters() {

		gyroAngle = drive.getGyroAngle();
		SmartDashboard.putNumber("gyroAngle", gyroAngle);
		SmartDashboard.putNumber("FrontSonarDistance", drive.getFrontSonarDistance());
		SmartDashboard.putNumber("DistanceLeftEncoder", drive.getDistanceLeftEncoder());
		SmartDashboard.putNumber("DistanceRightEncoder", drive.getDistanceRightEncoder());
		SmartDashboard.putNumber("RearSonarDistance", drive.getRearSonarDistance());
		// SmartDashboard.putNumber("ForkPosition", wrist.getForkPosition());
		SmartDashboard.putNumber("Inner", elevator.getDistanceInnerSectionEncoder());
		SmartDashboard.putNumber("Outer", elevator.getDistanceOuterSectionEncoder());
		// visionData.readVisionData();

	}

	/**
	 * returns position of current teams starting location
	 * 
	 * @return int 1=left 2=center 3=right
	 */
	public int getStartLocation() {
		return this.startLocation;
	}

	/**
	 * returns the team color
	 * 
	 * @return char R = Red, B = Blue, I = Invalid
	 */
	public char getColor() {
		String color_name = this.alliance.name().toString();
		return color_name.charAt(0);
	}

	public void flashLights() {
		int maxVal = 3;

		int mod = (int) (100 - (200 * drive.getAveragePower()));
		if (mod < 3)
			mod = 3;

		if (cycleCounter++ % mod == 0) {
			camera.light(currentLight++);
			if (currentLight > maxVal)
				currentLight = 1;
		}
	}

	public void flashLogo() {
		int duration = 20;

		if (logoCycleCounter++ % duration == 0) {
			camera.toggleLogoLight();
		}
	}

}
